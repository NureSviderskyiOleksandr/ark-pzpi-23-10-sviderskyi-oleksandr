МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»


ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторінг коду»
на тему «Методи рефакторингу коду: Encapsulate Field, Remove Control Flag, Replace Array with Object для мови програмування Ruby»





Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-10                                                       Старший викл. Кафедри ПІ
Свідерський О.Г                                                          Сокорчук І.П.



Харків 2025
1.  ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
05.11.2025
0.1
Створено структуру документа, додано розділ «Завдання»
2
09.11.2025
0.2
Додано теоретичні відомості (розділ 3.1, 3.2)
3
11.11.2025
0.3
Додано приклади коду (розділ 3.2.1 – 3.2.3)
4
12.11.2025
1.0
Додано розділи «Висновки», «Використані джерела» та додатки А, Б, В


2. ЗАВДАННЯ
   Дослідити поняття «рефакторинг коду», його основну мету та переваги. Ознайомитись з ключовими методами рефакторингу. Детально проаналізувати та продемонструвати на прикладах мовою програмування Ruby наступні техніки:
1. Encapsulate Field (Інкапсуляція Поля);
2. Remove Control Flag (Видалення Прапора);
3. Replace Array with Object (Заміна Масиву Об’єктом).
Описати покроковий процес безпечного рефакторингу та інструменти, що використовуються в Ruby.


     3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1. Поняття та мета рефакторингу
Рефакторинг — це процес зміни внутрішньої структури програмної системи, що не змінює її зовнішню поведінку, але покращує її якість та полегшує подальшу підтримку.
Основна мета рефакторингу полягає у покращенні якості існуючого коду. До ключових переваг належать:
1. Покращення дизайну коду: Код стає більш зрозумілим, гнучким та легшим для підтримки.
2. Полегшення пошуку багів: Спрощена структура коду допомагає швидше виявляти помилки.
3. Прискорення розробки: Чистий код легше розширювати, додаючи нові функції11.
4. Покращення читабельності: Код, який легко читати, легше розуміти та модифікувати.
     3.2. Ключові методи рефакторингу
     У ході роботи було детально розглянуто три методи рефакторингу на прикладах мовою Rubу.
3.2.1. Encapsulate Field
     Метод 1: Encapsulate Field (Інкапсуляція Поля)
     Опис: Цей метод обмежує прямий доступ до поля класу. Замість того, щоб робити змінну екземпляра (@variable) публічною (напр., через attr_accessor), вона робиться приватною і доступ до неї надається через спеціальні методи (геттери та сеттери).
     Реалізація: Це дозволяє додати логіку або валідацію при читанні чи записі даних. Наприклад, можна автоматично форматувати ім'я при його збереженні.
Приклад коду:
ДО: Прямий доступ до поля 
class User
  attr_accessor :name
end
user = User.new
user.name = "   іван  "
#=> user.name == "   іван  "

ПІСЛЯ: Доступ через методи
class User
  attr_reader :name
  def name=(new_name)
    @name = new_name.strip.capitalize
  end
end
user = User.new
user.name = "   іван  "
#=> user.name == "Іван" 

     3.2.2. Remove Control Flag
     Метод 2: Remove Control Flag (Видалення Прапора)
     Опис: Цей метод замінює логічну змінну (прапор), яка використовується для контролю виходу з циклу, на більш чисті та зрозумілі конструкції мови програмування.
Реалізація: Замість встановлення прапора (found = true) і перевірки його на кожній ітерації, можна негайно вийти з циклу або методу, використовуючи break (для виходу з циклу) або return (для виходу з методу).
Приклад коду:
ДО: Зайвий прапорець
def find_admin(users)
  result = nil 
  admin_found = false 
  users.each do |user| 
    if user.admin? && !admin_found 
      result = user 
      admin_found = true 
    end
  end
  return result
end

ПІСЛЯ: Використання break / return
def find_admin(users)
  users.each do |user| 
    # Негайне повернення 
    if user.admin?
      return user 
    end
  end
  return nil 
end



     3.2.3. Replace Array with Object
     Метод 3: Replace Array with Object (Заміна Масиву Об'єктом)
     Опис: Застосовується, коли масив використовується для зберігання різнорідних даних, і доступ до них відбувається за числовими індексами (напр., item[0], item[1]). Це робить код незрозумілим через "магічні індекси".
Реалізація: Масив замінюється на спеціалізований клас (об'єкт), де кожен елемент масиву стає полем класу з осмисленим ім'ям. Це покращує читабельність, надійність та відкриває можливості для додавання нової поведінки до цього класу.
Приклад коду:
ДО: "Магічні" індекси
# [назва, ціна, кількість]
order_item = ["Ноутбук", 1500.00, 2]
def calculate_total(item)
  item[1] * item[2]
end
total = calculate_total(order_item)

ПІСЛЯ: Спеціалізований клас
class LineItem
  attr_reader :name, :price, :quantity
  def initialize(name, price, quantity)
    @name = name
    @price = price
    @quantity = quantity
  end
  def total
    @price * @quantity
  end
end
order_item = LineItem.new("Ноутбук", 1500.00, 2)
total = order_item.total

3.3. Покроковий процес рефакторингу
Безпечний рефакторинг вимагає дисциплінованого підходу, який спирається на тестування:
1. Крок 1: Тести. Написати тести, які перевіряють поточну поведінку. Це "запобіжна сітка".
2. Крок 2: Аналіз. Визначити "код з запахом" (code smell) та обрати відповідний метод рефакторингу.
3. Крок 3: Малі зміни. Застосовувати рефакторинг невеликими, атомарними кроками. Не намагатися змінити все одразу.
4. Крок 4: Запуск тестів. Після кожного малого кроку запускати тести, щоб переконатися, що нічого не зламалося.
   3.4. Інструменти для рефакторингу в Ruby
   Для допомоги в рефакторингу в екосистемі Ruby існують спеціалізовані інструменти:
• RuboCop: Статичний аналіз коду (linting). Багато "копів" можуть автоматично виправляти прості проблеми, виконуючи мікро-рефакторинг.
• IDE (RubyMine, VS Code): Сучасні редактори мають вбудовані інструменти, такі як "Rename Variable" чи "Extract Method", які автоматизують рутинні операції.
• Тести та розуміння принципів: Найпотужнішим інструментом є тести (RSpec, Minitest) та розуміння принципів SOLID, GRASP.


     4. ВИСНОВКИ
     Під час виконання практичного завдання було детально розглянуто поняття рефакторингу – контрольованого процесу покращення внутрішньої структури коду без зміни його зовнішньої поведінки. Було проаналізовано ключові цілі рефакторингу, серед яких покращення дизайну та читабельності коду, полегшення пошуку багів та прискорення подальшої розробки.
   Отримано практичні навички застосування трьох поширених методів рефакторингу на прикладах мови Ruby:
1. Encapsulate Field (для додання логіки та валідації при доступі до полів);
2. Remove Control Flag (для спрощення логіки циклів шляхом заміни прапорців на return або break);
3. Replace Array with Object (для заміни "магічних індексів" на об'єкти з полями, що мають осмислені імена).
   Було засвоєно, що рефакторинг — це не окрема задача, а постійний процес, який є невід'ємною частиною здорового циклу розробки. Його слід застосовувати перед додаванням нових функцій, під час виправлення багів та в процесі код-рев'ю. Це підтверджує відому цитату Мартіна Фаулера: "Будь-який дурень може написати код, який зрозуміє комп'ютер. Хороші програмісти пишуть код, який розуміють люди".


   5.  ВИКОРИСТАНІ ДЖЕРЕЛА
1. Офіційна документація Ruby https://ruby-doc.org
2. Ruby Style Guide (стиль написання коду) https://rubystyle.guide
3. Мартін Роберт. М25 Чистий код: створення і рефакторинг за допомогою Agile – ФАБУЛА, 2019. – 416 с. 


ДОДАТОК А
Посилання відео на Youtube
Відеозапис доповіді: https://youtu.be/ZGpyJIFqVDg
Хронологічний опис відеозапису:
0:00 – Вступ 
0:25 – Вступ до рефакторингу 
0:53 – Мета рефакторингу
1:50 – Ключові методи рефакторингу
2:00 – Метод 1, Інкапсуляція поля
2:54 – Приклад використання методу №1
4:13 – Метод 2, Видалення прапора
5:31 – Приклад виконання методу №2
6:10 – Метод, Заміна масива об’єктом
7:14 – Приклад виконання методу №3
8:27 – Особистий код студента
9:44 – Прокова демонстрація рефакторингу
11:01 – Інструменти рефакторингу коду на Ruby
12.00 – Висновки
12.25 – Коли та як?

ДОДАТОК Б
Слайди презентації
Рисунок Б.1 – Титульний слайд

Рисунок Б.2 – Що таке рефакторинг?
Рисунок Б.3 – Мета рефакторингу

Рисунок Б.4 – Методи рефакторингу
Рисунок Б.5 – Метод 1

Рисунок Б.6 – Метод 1 (приклад)
Рисунок Б.7 – Метод 2

Рисунок Б.8 – Метод 2 (приклад)
Рисунок Б.9 – Метод 3

Рисунок Б.10 – Метод 3 (приклад)
Рисунок Б.11 – Код студента

Рисунок Б.12 – Покрокова демонстрація рефакторингу

Рисунок Б.13 – Інструменти для рефакторингу

Рисунок Б.14 – Висновки

Рисунок Б.15 – Важливість

Рисунок Б.16 – Список використаних джерел


ДОДАТОК В
Програмний код
     У цьому прикладі будь-який зовнішній код може напряму змінювати стан (@status) та склад (@items) замовлення, що призводить до відсутності контролю та ризику некоректних даних.
GitHub репозиторій: https://github.com/NureSviderskyiOleksandr/ark-pzpi-23-10-sviderskyi-oleksandr/blob/main/Pract2/pzpi-23-10-sviderskyi-oleksandr-pract2/code_examples_refactoring_methods.rb
# --- В.1 Метод "Encapsulate Field" – "До" рефакторингу ---
# Поля @status та @items є публічними для запису
class Order
  attr_accessor :status, :items
  def initialize
    @status = :pending
    @items = []
  end
  def total_price
    @items.sum(&:price)
  end
end
class PaymentService
  def process_payment(order)
    # ... логіка оплати ...
    # ПОГАНО: Зовнішній клас напряму змінює стан замовлення.
    # Що як ми забудемо зняти товари зі складу?
    order.status = :paid
  end
end
# --- Використання (До) ---
order = Order.new
# ПОГАНО: Можна напряму додати товар, оминувши будь-які перевірки
# (наприклад, перевірку наявності на складі).
order.items << Product.new(name: "Test", price: 100)
order.items << nil # Також можна додати невалідні дані

# ПОГАНО: Можна встановити будь-який неіснуючий статус.
order.status = :shipped_yesterday # Невалідний статус

     Ми приховуємо прямий доступ до полів. Замість цього ми надаємо методи (add_item, pay!, ship!), які керують станом. Тепер клас Order сам відповідає за свою цілісність.
GitHub репозиторій: https://github.com/NureSviderskyiOleksandr/ark-pzpi-23-10-sviderskyi-oleksandr/blob/main/Pract2/pzpi-23-10-sviderskyi-oleksandr-pract2/code_examples_refactoring_methods.rb
# --- В.2 Метод "Encapsulate Field" – "Після" рефакторингу ---

class OrderRefactored
  # Дозволяємо читати стан, але не змінювати напряму
  attr_reader :status, :items

  def initialize
    @status = :pending
    @items = []
  end

  def total_price
    @items.sum(&:price)
  end

  # ДОБРЕ: Спеціалізований метод для додавання
  def add_item(product)
    raise "Product cannot be nil" if product.nil?
    # Можна додати логіку: check_stock(product)
    @items << product
    puts "#{product.name} додано до замовлення."
  end

  # ДОБРЕ: Методи, що контролюють зміну стану
  def pay!
    # Тут може бути логіка перевірки
    @status = :paid
    puts "Замовлення оплачено."
    # send_invoice
  end

  def ship!
    if @status == :paid
      @status = :shipped
      puts "Замовлення відправлено."
      # reduce_stock
    else
      puts "Неможливо відправити неоплачене замовлення."
    end
  end
end
# --- Використання (Після) ---
order_r = OrderRefactored.new
product = Product.new(name: "Ноутбук", price: 1500)

order_r.add_item(product)
# order_r.add_item(nil) # => "Product cannot be nil" (RuntimeError)

# order_r.status = :paid # => NoMethodError: private method `status='
order_r.ship! # => "Неможливо відправити неоплачене замовлення."
order_r.pay!  # => "Замовлення оплачено."
order_r.ship! # => "Замовлення відправлено."
     
     
     
     Метод process_batch використовує прапор found_error для зупинки обробки у випадку помилки. Це робить логіку громіздкою: цикл продовжує ітерації, навіть коли помилку вже знайдено, а всередині циклу потрібна постійна перевірка if !found_error.
GitHub репозиторій: https://github.com/NureSviderskyiOleksandr/ark-pzpi-23-10-sviderskyi-oleksandr/blob/main/Pract2/pzpi-23-10-sviderskyi-oleksandr-pract2/code_examples_refactoring_methods.rb
      # --- В.3 Метод "Remove Control Flag" – "До" рефакторингу ---
      
      class TransactionProcessor
        def process_batch(transactions)
          found_error = false # Керуючий прапор
          error_message = nil
      
          transactions.each do |tx|
            # Логіка ускладнюється через перевірку прапора
            if !found_error
              if tx.amount > tx.user.balance
                # Встановлюємо прапор
                found_error = true
                error_message = "Помилка (ID: #{tx.id}): Недостатньо коштів."
              elsif tx.amount <= 0
                found_error = true
                error_message = "Помилка (ID: #{tx.id}): Некоректна сума."
              else
                # Обробка валідної транзакції
                puts "Обробка транзакції #{tx.id}..."
                tx.execute
              end
            end
          end
      
          if found_error
            puts "Обробку зупинено. #{error_message}"
            return false
          else
            puts "Усі транзакції успішно оброблено."
            return true
          end
        end
      end
     
     Ми повністю видаляємо прапор found_error. Використовуючи "раннє повернення" (early return), ми негайно виходимо з методу, як тільки виявлено проблему. Код стає лінійним, плоским та набагато легшим для читання.
GitHub репозиторій: https://github.com/NureSviderskyiOleksandr/ark-pzpi-23-10-sviderskyi-oleksandr/blob/main/Pract2/pzpi-23-10-sviderskyi-oleksandr-pract2/code_examples_refactoring_methods.rb
      # --- В.4 Метод "Remove Control Flag" – "Після" рефакторингу ---
      
      class TransactionProcessorRefactored
        def process_batch(transactions)
          # Використовуємо .each, щоб мати змогу вийти з методу через `return`
          transactions.each do |tx|
            if tx.amount > tx.user.balance
              # Негайний вихід з методу
              puts "Обробку зупинено. Помилка (ID: #{tx.id}): Недостатньо коштів."
              return false
            end
      
            if tx.amount <= 0
              puts "Обробку зупинено. Помилка (ID: #{tx.id}): Некоректна сума."
              return false
            end
      
            # Цей код виконається, тільки якщо всі перевірки пройдені
            puts "Обробка транзакції #{tx.id}..."
            tx.execute
          end
      
          # Якщо цикл завершився без `return false`, значить все добре
          puts "Усі транзакції успішно оброблено."
          return true
        end
      end
     
     Система статистики використовує масив для зберігання даних про користувача [id, username, email, last_login_date]. Це призводить до використання "магічних індексів" (0, 1, 3), що робить код незрозумілим і крихким (якщо порядок зміниться, все зламається).
GitHub репозиторій: https://github.com/NureSviderskyiOleksandr/ark-pzpi-23-10-sviderskyi-oleksandr/blob/main/Pract2/pzpi-23-10-sviderskyi-oleksandr-pract2/code_examples_refactoring_methods.rb
      # --- В.5 Метод "Replace Array with Object" – "До" рефакторингу ---
      
      class UserReport
        # Метод отримує "сирі" дані, наприклад, з DB-запиту
        def generate_activity_report(raw_data)
          puts "Звіт про активність користувачів:"
          puts "-----------------------------------"
          
          active_users = raw_data.select do |user_array|
            # ПОГАНО: магічний індекс [3] (last_login_date)
            # Ми не знаємо, що таке [3] без документації.
            user_array[3] > (Time.now - 30 * 86400) # 30 днів
          end
      
          active_users.each do |user_array|
            # ПОГАНО: магічні індекси [1] (username) та [2] (email)
            puts "Активний користувач: #{user_array[1]} (Email: #{user_array[2]})"
          end
          
          puts "-----------------------------------"
          puts "Всього активних: #{active_users.count}"
        end
      end
      
      # --- Використання (До) ---
      # Дані, що прийшли з бази даних у вигляді масиву масивів
      db_data = [
        [1, "admin", "admin@example.com", Time.now - 86400 * 5],
        [2, "alice", "alice@example.com", Time.now - 86400 * 40],
        [3, "bob", "bob@example.com", Time.now - 86400 * 10]
      ]
      
      report = UserReport.new
      report.generate_activity_report(db_data)
     
     Ми створюємо простий клас (або Struct) UserRecord, який дає кожному елементу даних осмислене ім'я. Ми перетворюємо "сирі" дані на масив цих об'єктів. Код стає самодокументованим, читабельним і надійним.
GitHub репозиторій: https://github.com/NureSviderskyiOleksandr/ark-pzpi-23-10-sviderskyi-oleksandr/blob/main/Pract2/pzpi-23-10-sviderskyi-oleksandr-pract2/code_examples_refactoring_methods.rb
      # --- В.6 Метод "Replace Array with Object" – "Після" рефакторингу ---
      
      # ДОБРЕ: Створюємо клас або Struct для представлення даних.
      # Struct ідеально підходить для таких простих "контейнерів даних".
      UserRecord = Struct.new(:id, :username, :email, :last_login_date)
      
      class UserReportRefactored
        def generate_activity_report(raw_data)
          # 1. Перетворюємо масиви на об'єкти
          user_records = raw_data.map do |row|
            UserRecord.new(row[0], row[1], row[2], row[3])
          end
      
          puts "Звіт про активність користувачів:"
          puts "-----------------------------------"
      
          # ДОБРЕ: Код читається як звичайна англійська
          active_users = user_records.select do |user|
            user.last_login_date > (Time.now - 30 * 86400) # 30 днів
          end
      
          active_users.each do |user|
            # ДОБРЕ: Ніяких індексів, тільки осмислені імена полів
            puts "Активний користувач: #{user.username} (Email: #{user.email})"
          end
          
          puts "-----------------------------------"
          puts "Всього активних: #{active_users.count}"
        end
      end
      
      # --- Використання (Після) ---
      # Дані ті самі
      db_data = [
        [1, "admin", "admin@example.com", Time.now - 86400 * 5],
        [2, "alice", "alice@example.com", Time.now - 86400 * 40],
        [3, "bob", "bob@example.com", Time.now - 86400 * 10]
      ]
      
      report_r = UserReportRefactored.new
      report_r.generate_activity_report(db_data)
